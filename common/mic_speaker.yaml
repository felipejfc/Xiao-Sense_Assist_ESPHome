esphome:
  on_boot:
    priority: 600
    then:
      - lambda: !lambda |-
          // Initialize PI4IOE5V6408 (matches pi4ioe_init)
          auto read_pi4io = id(pi4io).read_byte(0x00); // REG_CTRL
          id(pi4io).write_byte(0x07, 0x00); // REG_IO_PP: High-impedance
          read_pi4io = id(pi4io).read_byte(0x07);
          id(pi4io).write_byte(0x0D, 0xFF); // REG_IO_PULLUP: Enable pull-ups
          id(pi4io).write_byte(0x03, 0x6E); // REG_IO_DIR: GPIO0 output, mixed
          read_pi4io = id(pi4io).read_byte(0x03);
          id(pi4io).write_byte(0x05, 0xFF); // REG_IO_OUT: Outputs high (unmute)
          read_pi4io = id(pi4io).read_byte(0x05);

          // ES8311 Initialization (matches es8311_init)
          // Reset sequence
          id(es8311).write_byte(0x00, 0x1F); // REG00: Reset
          delay(20);
          id(es8311).write_byte(0x00, 0x00); // REG00: Clear reset
          id(es8311).write_byte(0x00, 0x80); // REG00: Power on

          // Clock Config (16kHz, 1.024MHz MCLK from SCK)
          id(es8311).write_byte(0x01, 0xBF); // REG01: Use SCLK, enable clocks
          
          // REG02: Read-modify-write for pre_div and pre_multi
          auto reg02 = id(es8311).read_byte(0x02).value_or(0x00);
          reg02 &= 0x07; // Preserve lower 3 bits
          reg02 |= (0x00 << 5); // pre_div - 1 = 1 - 1 = 0
          reg02 |= (0x02 << 3); // pre_multi = 2
          id(es8311).write_byte(0x02, reg02); // REG02: Write 0x10
          
          id(es8311).write_byte(0x03, 0x10); // REG03: fs_mode=0, adc_osr=0x10
          id(es8311).write_byte(0x04, 0x10); // REG04: dac_osr=0x10
          id(es8311).write_byte(0x05, 0x00); // REG05: adc_div=1, dac_div=1
          
          // REG06: Read-modify-write for bclk_div
          auto reg06 = id(es8311).read_byte(0x06).value_or(0x00);
          reg06 &= 0xE0; // Preserve upper 3 bits
          reg06 |= (0x04 - 1); // bclk_div = 4, so 4 - 1 = 3
          id(es8311).write_byte(0x06, reg06); // REG06: Write 0x03
          
          // REG07: Read-modify-write for lrck_h
          auto reg07 = id(es8311).read_byte(0x07).value_or(0x00);
          reg07 &= 0xC0; // Preserve upper 2 bits
          reg07 |= 0x00; // lrck_h = 0
          id(es8311).write_byte(0x07, reg07); // REG07: Write 0x00
          
          id(es8311).write_byte(0x08, 0xFF); // REG08: lrck_l=0xFF

          // Format Config (32-bit, matches ES8311_RESOLUTION_32)
          auto reg00 = id(es8311).read_byte(0x00).value_or(0x00);
          reg00 &= 0xBF; // Clear master mode bit
          id(es8311).write_byte(0x00, reg00); // REG00: Slave mode
          id(es8311).write_byte(0x09, 0x10); // REG09: 32-bit (4 << 2)
          id(es8311).write_byte(0x0A, 0x10); // REG0A: 32-bit (4 << 2)

          // Microphone Config
          id(es8311).write_byte(0x14, 0x1A); // REG14: Analog MIC, max PGA gain
          id(es8311).write_byte(0x16, 0x01); // REG16: 6dB gain (matches setMicGain(ES8311_MIC_GAIN_6DB))
          id(es8311).write_byte(0x17, 0xFF); // REG17: Max ADC gain

          // System Registers
          id(es8311).write_byte(0x0D, 0x01); // REG0D: Power up analog
          id(es8311).write_byte(0x0E, 0x02); // REG0E: Enable PGA, ADC modulator
          id(es8311).write_byte(0x12, 0x00); // REG12: Power up DAC
          id(es8311).write_byte(0x13, 0x10); // REG13: Enable HP output
          id(es8311).write_byte(0x1C, 0x6A); // REG1C: ADC equalizer bypass, DC offset
          id(es8311).write_byte(0x37, 0x08); // REG37: Bypass DAC equalizer


i2s_audio:
  - id: i2s_sound
    i2s_lrclk_pin: ${i2s_lrclk_pin}
    i2s_bclk_pin: ${i2s_bclk_pin}


microphone:
  - platform: i2s_audio
    i2s_audio_id: i2s_sound
    id: echo_microphone
    i2s_din_pin: ${i2s_din_pin}
    channel: ${microphone_channel}
    sample_rate: 16000
    bits_per_sample: 32bit
    pdm: ${microphone_pdm}
    adc_type: ${microphone_adc_type}


i2c:
  - id: bus_b
    sda: GPIO38
    scl: GPIO39
    scan: True


i2c_device:
  - id: pi4io
    address: 0x43
    i2c_id: bus_b
  - id: es8311
    address: 0x18
    i2c_id: bus_b


speaker:
  - platform: i2s_audio
    id: speaker_output
    i2s_audio_id: i2s_sound
    i2s_dout_pin: ${i2s_dout_pin}
    dac_type: external
    sample_rate: 16000
    bits_per_sample: 32bit
    channel: left


number:
  - platform: template
    name: Speaker Volume
    id: speaker_volume
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 50
    on_value:
      then:
      - script.execute:
          id: set_speaker_volume
          volume: !lambda 'return id(speaker_volume).state;'


# Scripts for Mute/Unmute
script:
  - id: turn_on_micro_wake_word
    then:
      - script.execute: mute_speaker
      - micro_wake_word.start:
  - id: turn_off_micro_wake_word
    then:
      - micro_wake_word.stop:
      - script.execute: unmute_speaker
  - id: set_speaker_volume
    parameters:
      volume: float
    then:
      - lambda: !lambda |-
          int vol = static_cast<int>(volume);
          int reg_value;
          if (vol == 0) {
            reg_value = 0;  // Mute
          } else {
            reg_value = (vol * 256 / 100) - 1;  // Scale to 0-255
          }
          id(es8311).write_byte(0x32, reg_value);
          ESP_LOGD("custom", "Set speaker volume to %d%%, reg_value=0x%02X", vol, reg_value);
  - id: mute_speaker
    then:
      - script.execute:
          id: set_speaker_volume
          volume: 0
      - logger.log: "Speaker muted"
  - id: unmute_speaker
    then:
      - script.execute:
          id: set_speaker_volume
          volume: !lambda 'return id(speaker_volume).state;'
      - logger.log: "Speaker unmuted"
  - id: mute_dac
    then:
      - lambda: !lambda |-
          auto reg31 = id(es8311).read_byte(0x31).value_or(0x00);
          id(es8311).write_byte(0x31, reg31 | 0x60); // REG31: Mute DAC (set bits 5-6)
          ESP_LOGD("ES8311", "REG31 after mute: %02x", id(es8311).read_byte(0x31).value_or(0x00));
      - logger.log: "DAC muted"
  - id: unmute_dac
    then:
      - lambda: !lambda |-
          auto reg31 = id(es8311).read_byte(0x31).value_or(0x00);
          id(es8311).write_byte(0x31, reg31 & 0x9F); // REG31: Unmute DAC (clear bits 5-6)
          ESP_LOGD("ES8311", "REG31 after unmute: %02x", id(es8311).read_byte(0x31).value_or(0x00));
      - logger.log: "DAC unmuted"


voice_assistant:
  id: voiceassistant
  speaker: speaker_output
  noise_suppression_level: ${assist_noise_suppression_level}
  
  on_stt_vad_end: 
    then:
      - script.execute: turn_off_micro_wake_word

  on_tts_stream_end:
    - if:
        condition:
          switch.is_on: use_wake_word
        then:
          - script.execute: turn_on_micro_wake_word